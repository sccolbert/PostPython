#------------------------------------------------------------------------------
# POSTPython Buffer Module
#
#
#------------------------------------------------------------------------------
from .numbers import Int64


# The builtin type-and-size aware heap memory allocator for PostPython.
#
# A `Buffer` object is a reference type.
#
# This type is intentionally low-level and does not provide any convenience
# methods. This does two things:
#   1) It makes it easier to implement and optimize by a backend.
#   2) It discourages its use by user code and encourages users
#      to use the higher level library containers instead.
#
# That said, this class *can* be used by low level code for finer-grained
# control over memory allocation.
class Buffer[T]:

    # The capacity of the buffer in number of `T` elements.
    #
    # This value is always `>= 0`.
    const capacity: Int64

    # The length of the buffer in number of `T` elements.
    #
    # The `length` is number of valid elements in the buffer.
    #
    # The `buffer` length will grow up to `capcity` as elements are assigned
    # to `index == length` at which point it will cease to grow.
    #
    # This is always `>= 0` and `<= capacity`.
    readonly length: Int64

    # Construct a `Buffer` object to hold `capcity` elements.
    #
    # The initial `length` of the buffer will be zero.
    def __init__(capacity: Int64): ...

    # Copy constructor.
    #
    # The new buffer has a new internal buffer populated by the other buffer.
    def __init__(other: Buffer[T]): ...

    # Resize copy constructor with new `capacity`.
    #
    # The new buffer has a new internal buffer populated by the buffer.
    #
    # Only logically "live" elements are copied into the new internal
    # buffer subject to the new `capacity` value.
    def __init__(other: Buffer[T], capacity: Int64): ...

    # Get the element at the specified buffer index.
    #
    # Indexing at `< length` is guaranteed to be a valid object.
    #
    # Indexing out-of-bounds is a programming error and the behavior
    # is implementation-defined.
    #
    # Indexing with negative values is a programming error and the
    # behavior is implementation defined.
    def __getitem__(index: Int64) -> T: ...

    # Set the element at the specified buffer index.
    #
    # Assigning to `index < length` will overwrite the element at that
    # index.
    #
    # Assigning to `index == length` will grow the `length` by `1` provided
    # there is sufficient `capacity`. If the buffer is full, the behavior
    # implementation-defined.
    #
    # Assigning at `index > length` is a programming error and the behavior
    # is implementation-defined.
    #
    # Indexing with negative values is a programming error and the behavior
    # is implementation defined.
    def __setitem__(index: Int64, value: T): ...

