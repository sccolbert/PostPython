
#-----------------------------------------------------------------------------
# The None Type
#-----------------------------------------------------------------------------

# The singleton None type. Denoted by the keyword `None`.
type None


#-----------------------------------------------------------------------------
# The Boolean Type
#-----------------------------------------------------------------------------

# The boolean type. Denoted by the keywords `true` or `false`.
type Bool


#-----------------------------------------------------------------------------
# Intrinsic Byte Type
#-----------------------------------------------------------------------------

# A single 8-bit byte
type Byte


# ----------------------------------------------------------------------------
# Intrinsic Unsigned Integer Types
#-----------------------------------------------------------------------------

# Unsigned 8-bit integer
type Uint8

# Unsigned 16-bit integer
type Uint16

# Unsigned 32-bit integer
type Uint32

# Unsigned 64-bit integer
type Uint64

# Unsigned 128-bit integer
type Uint128


#-----------------------------------------------------------------------------
# Intrinsic Signed Integer Types
#-----------------------------------------------------------------------------

# Signed 8-bit integer
type Int8

# Signed 16-bit integer
type Int16

# Signed 32-bit integer
type Int32

# Signed 64-bit integer
type Int64

# Signed 128-bit integer
type Int128


#-----------------------------------------------------------------------------
# Intrinsic Floating Point Types
#-----------------------------------------------------------------------------

# IEE-754 32bit floating point
type Float32

# IEE-754 64bit floating point
type Float64

# IEE-754 128bit floating point
type Float128


#-----------------------------------------------------------------------------
# Intrinsic Complex Types
#-----------------------------------------------------------------------------

# 32bit complex type
type Complex32:

	# The real component of the complex type.
	readonly real: Float32

	# The imaginary component of the complex type.
	readonly imag: Float32


# 64bit complex type
type Complex64:

	# The real component of the complex type.
	readonly real: Float64

	# The imaginary component of the complex type.
	readonly imag: Float64


# 128bit complex type
type Complex128:

	# The real component of the complex type.
	readonly real: Float128

	# The imaginary component of the complex type.
	readonly imag: Float128


#-----------------------------------------------------------------------------
# Buffer Type
#-----------------------------------------------------------------------------

# The core buffer type.
# 
# A buffer represents core device memory. It has no concept of length or out
# of bounds access. The only operation it supports is indexing. Indexing a 
# buffer will return the value of the given type at that location, or it may
# segfault if the index out-of-bounds.
# 
# Most code will interact with the `Memory` type, not `buffer`.
#
# User code cannot allocate or free a `buffer`. It must use the `Memory`
# type instead.
#
# Mis-use of the buffer type is undefined behavior.
type Buffer[T]:
	
	# Retrieve the element at the specified index.
	#
	# For example, `value = buffer[0]`.
	#
	# The compiler/runtime does not check this access for out-of-bounds, so 
	# it must be used safely by the calling code, or undefined behavior may 
	# result.
	def __getitem__(self, index: Uint64) -> T:
		pass

	# Assign a value at the specified index.
	#
	# For example, `buffer[0] = value`.
	#
	# The compiler/runtime does not check this access for out-of-bounds, so 
	# it must be used safely by the calling code, or undefined behavior may 
	# result.
	def __setitem__(self, index: Uint64, value: T) -> T:
		pass


#-----------------------------------------------------------------------------
# Memory Type
#-----------------------------------------------------------------------------

# The core size-aware memory type for heap allocation.
#
# Note that the size of the underlying device buffer in bytes is "at least" 
# large enough to hold `n = length` elements, but it may be greater.
type Memory[T]:

	# The length of the memory buffer in number of `T` elements.
	#
	# This value is `readonly` and cannot be changed by the user.
	readonly length: Uint64

	# The buffer holding at-least `length` elements.
	#
	# This buffer can be accessed with `0-based` indexing up to `length-1`.
	#
	# Indexing out-of-bounds is undefined or implementation-specific behavior.
	#
	# This value is `readonly` and cannot be changed by the user. However, the
	# element values of the buffer are read-write by the user.
	#
	# Note that element bounds-checks are up to the implementation.
	readonly buffer: Buffer[T]

	# Construct a `Memory` object to hold `length` elements of the given type.
	#
	# If the allocation fails, an exception will be raised.
	#
	# All elements of the buffer will be initialized to `zero` in memory.
	def __init__(self, length: Uint64):
		pass

	# [pragma inline]
	def __getitem__(self, index: Uint64) -> T:
		return self.buffer[index]

	# [pragma inline]
	def __setitem__(self, index: Uint64, value: T) -> None:
		self.buffer[index] = value
		
	# Resize the `Memory` object to hold "at least" `length` elements.
	#
	# Note, the behavior of this method is implementation-dependent. An 
	# implementation may move the memory buffer pointer, or it may not. 
	# It may copy memory, or it may not.
	#
	# Guarantees from the implentation on success are as follows:
	# - If resizing larger, all new elements are initialized to zero.
	# - If resizing smaller, all dead elements are freed.
	# - If moving the buffer pointer, all valid elements are copied.
	#
	# The `resize` operation is not thread-safe unless otherwise specified
	# by an implementation.
	#
	# If this operation fails, an exception will be raised.
	def resize(self, length: Uint64):
		pass

	# Free the device memory owned by this object.
	#
	# After this call, the `Memory` object is invalid and accessing it after
	# this call is undefined behvior, or implementation-specific.
	#
	# Guarantees from the implementation are as follows:
	# - The entire memory buffer will be over-written with `zero`.
	#
	# Whether this function fails (i.e. double-free) is specific to the
	# implementation. Should it fail, an exception will be raised.
	def free(self):
		pass
